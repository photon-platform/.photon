#!/usr/bin/env bash

# LAST_ERROR=$?

# Highlight the user name when logged in as root.
if [[ "${USER}" == "root" ]]; then
  userStyle="${fgRed}"
else
  userStyle="${fgYellow}"
fi

# Highlight the hostname when connected via SSH.
if [[ "${SSH_TTY}" ]]; then
  hostStyle="${fgRed}"
else
  hostStyle="${fgAqua}"
fi

BDOT='\[${fgg00}\]$DOT\[${txReset}\]'

# Set the terminal title and prompt.
# Use \[...\] around the parts of PS1 that have length 0. 
PS1='\n'
PS1+='$(hr_prompt)'
PS1+='\n'
# PS1+=" \[${userStyle}\]\u"; # username
# PS1+=' \u'; # username
PS1+=' \[${fgg12}\]\u\[${txReset}\]'
PS1+=' \[${fgg08}\]$DOT\[${txReset}\]'
# PS1+="\[${hostStyle}\]\h "; # host
# PS1+=' \h'; # host
PS1+=' \[${fgg12}\]\h\[${txReset}\]'
PS1+=' \[${fgg08}\]$DOT\[${txReset}\]'
PS1+=' \t'; # time
PS1+='\n'
PS1+='\[${fgg12}\]'
PS1+=' $(git_branch)'
PS1+='\[${txReset}\]'
PS1+=' \[${fgg08}\]$DOT\[${txReset}\]'
PS1+='\[${fgg16}\]'
PS1+=' $(gsss)'
PS1+='\[${txReset}\]'
PS1+=' \[${fgg08}\]$DOT\[${txReset}\]'
# PS1+=" \[${fgRed}\]${g_s}\[${txReset}\] " 
# PS1+=" \[${fgYellow}\]\w"; # working directory full path
PS1+=' \[${fgg24}\]\w\[${txReset}\]'
# PS1+=' \w'; # working directory full path
PS1+='\n'
# if [ $LAST_ERROR -ne 0 ]; then
  # PS1+=" ${txBold}${fgRed}$?"
# fi
# PS1+=" \[${txReset}\]\n"
PS1+=' > '; 
export PS1

# continuation prompt
PS2="   \[${fgYellow}\]→ \[${txReset}\]"
export PS2

# prompt_git() {
  # s=""
  # branchName=""

  # # Check if the current directory is in a Git repository.
  # if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

    # # check if the current directory is in .git before running git checks
    # if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

      # # Ensure the index is up to date.
      # git update-index --really-refresh -q &>/dev/null

      # # Check for uncommitted changes in the index.
      # if ! $(git diff --quiet --ignore-submodules --cached); then
        # s+='+'
      # fi

      # # Check for unstaged changes.
      # if ! $(git diff-files --quiet --ignore-submodules --); then
        # s+='!'
      # fi

      # # Check for untracked files.
      # if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        # s+='?'
      # fi

      # # Check for stashed files.
      # if $(git rev-parse --verify refs/stash &>/dev/null); then
        # s+='$'
      # fi
    # fi

    # # Get the short symbolic ref.
    # # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
    # # Otherwise, just give up.
    # branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            # git rev-parse --short HEAD 2> /dev/null || \
            # echo '(unknown)')"

    # [ -n "${s}" ] && s=" [${s}]"

    # printf "\[${fgPurple}\]%s\[${txReset}\] " $branchName
    # printf "\[${fgRed}\]%s\[${txReset}\] " $s
  # else
    # return
  # fi
# }
